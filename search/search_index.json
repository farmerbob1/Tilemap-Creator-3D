{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tilemap Creator 3D Overview This package contains an editor editor extension for speeding up the development with mesh based tiles inside the Unity engine. It's features and modular extensibility make it widely usable over all kind of projects both at editor and runtime. Features Components for authoring tile based maps (processing via modular sub components) Mesh based tile setups via different included types (Single / Multi / Auto) Mesh module using Unitys Job System to efficiently combine Mesh Tiles into a large mesh (supports chunking) Collision module to create optimized box compound colliders (supports mesh colliders if needed) Navigation module for baking a Unity NavMesh for the map Interfaces to provide custom modules / tiletypes if required Requirements Unity 2021+ (tested on 2021.3) Install instructions Start a new Unity Project and navigate to the Package Manager (Window > Package Manager). Open the [+] dropdown and select \"Add package from git URL ...\". The URL is the adress of this repository.","title":"Home"},{"location":"#tilemap-creator-3d-overview","text":"This package contains an editor editor extension for speeding up the development with mesh based tiles inside the Unity engine. It's features and modular extensibility make it widely usable over all kind of projects both at editor and runtime.","title":"Tilemap Creator 3D Overview"},{"location":"#features","text":"Components for authoring tile based maps (processing via modular sub components) Mesh based tile setups via different included types (Single / Multi / Auto) Mesh module using Unitys Job System to efficiently combine Mesh Tiles into a large mesh (supports chunking) Collision module to create optimized box compound colliders (supports mesh colliders if needed) Navigation module for baking a Unity NavMesh for the map Interfaces to provide custom modules / tiletypes if required","title":"Features"},{"location":"#requirements","text":"Unity 2021+ (tested on 2021.3)","title":"Requirements"},{"location":"#install-instructions","text":"Start a new Unity Project and navigate to the Package Manager (Window > Package Manager). Open the [+] dropdown and select \"Add package from git URL ...\". The URL is the adress of this repository.","title":"Install instructions"},{"location":"extensions/","text":"Extending the tool The package has multiple interfaces that allow the user to add his/her custom script components into the pipeline. I reccomend taking a look at the WorldMap sample which shows some actual implementations. Adding a custom tile type Create a new class extending the Tilemap3D.BaseTile. Tile types are centered around the TileInfo struct which consists of { Mesh / CollisionType / CollisionMesh } Each tile also recives a sub index that can be used if a tile has multiple variants. If your tile targets a custom module that does not need this information (example one that adds GameObjects) feel free to return an empty TileInfo. public class CustomTile:BaseTile { // How many sub tile variants are expected public override int Length { get; } // Give reference to the tile info struct used to store mesh / collisiontype / collisionmesh at the requested variant index public override TileInfo GetInfo(int index); // Which mesh should the picker show? public override Mesh GetTilePreview(int index) => null; // This will run after tile placement is complete. It can be used for adjusting tiles depending on their environment public override void PostProcessTile(ref TileMapData data, int3 pos) { } } Add a custom module Create a Monobehaviour that includes the interface Tilemap3D.ITilemapModule. To register a module for easier access refer to the next section. The structure of a module is as follows: public class MyModule:Monobehaviour, ITilemapModule { // Used to update a specific part of the tilemap immediatly on tile placement. Keep heavy calculations to a minimum public void BakePartial(Tilemap map, Box3D area) {} // Bake calculation or garbage heavy data on demans void Bake(Tilemap map); // Clear baked data on demand void Clear(); } Register an extension in the editor Create a new static class and and give it an appropriate name. The class needs the [InitializeOnLoad] attribute to register before everything else. Inside the class add a static constrctor with the same name as the class. Use the TilemapSettings class inside the Tilemap3D.EditorOnly namespace to register your additions. [InitializeOnLoad] public class MyRegisterClass { static MyRegisterClass () { // Register a module to the Tilemap dropdown TilemapSettings.instance.RegisterModule<MyCustomModule>(); // Register a flag to be shown in the toolbar (Up to 8 flags in total. Flag 0 and 1 are already used by autotile) TilemapSettings.instance.RegisterFlagContent(new GUIContent(image, tooltip), yourID); } }","title":"Writing Extensions"},{"location":"extensions/#extending-the-tool","text":"The package has multiple interfaces that allow the user to add his/her custom script components into the pipeline. I reccomend taking a look at the WorldMap sample which shows some actual implementations.","title":"Extending the tool"},{"location":"extensions/#adding-a-custom-tile-type","text":"Create a new class extending the Tilemap3D.BaseTile. Tile types are centered around the TileInfo struct which consists of { Mesh / CollisionType / CollisionMesh } Each tile also recives a sub index that can be used if a tile has multiple variants. If your tile targets a custom module that does not need this information (example one that adds GameObjects) feel free to return an empty TileInfo. public class CustomTile:BaseTile { // How many sub tile variants are expected public override int Length { get; } // Give reference to the tile info struct used to store mesh / collisiontype / collisionmesh at the requested variant index public override TileInfo GetInfo(int index); // Which mesh should the picker show? public override Mesh GetTilePreview(int index) => null; // This will run after tile placement is complete. It can be used for adjusting tiles depending on their environment public override void PostProcessTile(ref TileMapData data, int3 pos) { } }","title":"Adding a custom tile type"},{"location":"extensions/#add-a-custom-module","text":"Create a Monobehaviour that includes the interface Tilemap3D.ITilemapModule. To register a module for easier access refer to the next section. The structure of a module is as follows: public class MyModule:Monobehaviour, ITilemapModule { // Used to update a specific part of the tilemap immediatly on tile placement. Keep heavy calculations to a minimum public void BakePartial(Tilemap map, Box3D area) {} // Bake calculation or garbage heavy data on demans void Bake(Tilemap map); // Clear baked data on demand void Clear(); }","title":"Add a custom module"},{"location":"extensions/#register-an-extension-in-the-editor","text":"Create a new static class and and give it an appropriate name. The class needs the [InitializeOnLoad] attribute to register before everything else. Inside the class add a static constrctor with the same name as the class. Use the TilemapSettings class inside the Tilemap3D.EditorOnly namespace to register your additions. [InitializeOnLoad] public class MyRegisterClass { static MyRegisterClass () { // Register a module to the Tilemap dropdown TilemapSettings.instance.RegisterModule<MyCustomModule>(); // Register a flag to be shown in the toolbar (Up to 8 flags in total. Flag 0 and 1 are already used by autotile) TilemapSettings.instance.RegisterFlagContent(new GUIContent(image, tooltip), yourID); } }","title":"Register an extension in the editor"},{"location":"faq/","text":"FAQ Can this be used to create games of genre X? Genre Support Comments Topdown Yes Main focus of the tool Rougelike Yes Procedural map generation not included 2.5D \"Yes\" Limited support on modules 2D No Use Unity Tilemap instead Blockgame No Data is stored in a fixed length array (not intended for huge worlds) Why only Unity 2021+ Unity 2019 does not support the new Mesh API and 2020 does not support custom toolbars. Where can I find the documentation? There is a subfolder called ~Documentation. In there you can find a selection of articles about the general usage. Is this URP/HDRP compatible? Yes. Is the tilemap runtime compatible? Yes and no. All the tile logic and meshing methods should be usable at runtime. The interface is Unity Editor only though so you will have to write your own runtime interface. I have an issue? Since this is a hobby project I do not offer live support. If you encountered a bug file an issue on the repository page. If it's about a feature request or something covered in the FAQ I might not feel inclined to answer though. Why is it not on the Asset Store? a) I don't see a lot of value from selling it. The maintenance cost / revenue ballance does not seem worth it b) I want to give users the ability to easily accsess and learn from the code Can I include this as part of a commercial offering? Please do not sell the source or include it inside a product sold via the Asset Store. Everything else is totally fine with me and covered by the license. Where do I get the tile meshes from? Sources of compatible 3D meshes are not common so you are for most part on your own. You can use a modeling tool like Blender to create your own tiles. There is a section in the documentation that goes over this topic. Can I contribute? The package itself is feature complete and I would like to keep the amount of contributors to a minimum so in most cases the answer is no. To avoid bloating the package itself new features are intended to be added as modules (check the documentation and the WorldMapSample to get a genreal idea). If you require some larger scale modifications to the source please create a fork instead. I created something using the package? (custom module or game) Feel free to drop me a message (mail is at the bottom of my portfolio page) and I will give you a shoutout in the documentation.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#can-this-be-used-to-create-games-of-genre-x","text":"Genre Support Comments Topdown Yes Main focus of the tool Rougelike Yes Procedural map generation not included 2.5D \"Yes\" Limited support on modules 2D No Use Unity Tilemap instead Blockgame No Data is stored in a fixed length array (not intended for huge worlds)","title":"Can this be used to create games of genre X?"},{"location":"faq/#why-only-unity-2021","text":"Unity 2019 does not support the new Mesh API and 2020 does not support custom toolbars.","title":"Why only Unity 2021+"},{"location":"faq/#where-can-i-find-the-documentation","text":"There is a subfolder called ~Documentation. In there you can find a selection of articles about the general usage.","title":"Where can I find the documentation?"},{"location":"faq/#is-this-urphdrp-compatible","text":"Yes.","title":"Is this URP/HDRP compatible?"},{"location":"faq/#is-the-tilemap-runtime-compatible","text":"Yes and no. All the tile logic and meshing methods should be usable at runtime. The interface is Unity Editor only though so you will have to write your own runtime interface.","title":"Is the tilemap runtime compatible?"},{"location":"faq/#i-have-an-issue","text":"Since this is a hobby project I do not offer live support. If you encountered a bug file an issue on the repository page. If it's about a feature request or something covered in the FAQ I might not feel inclined to answer though.","title":"I have an issue?"},{"location":"faq/#why-is-it-not-on-the-asset-store","text":"a) I don't see a lot of value from selling it. The maintenance cost / revenue ballance does not seem worth it b) I want to give users the ability to easily accsess and learn from the code","title":"Why is it not on the Asset Store?"},{"location":"faq/#can-i-include-this-as-part-of-a-commercial-offering","text":"Please do not sell the source or include it inside a product sold via the Asset Store. Everything else is totally fine with me and covered by the license.","title":"Can I include this as part of a commercial offering?"},{"location":"faq/#where-do-i-get-the-tile-meshes-from","text":"Sources of compatible 3D meshes are not common so you are for most part on your own. You can use a modeling tool like Blender to create your own tiles. There is a section in the documentation that goes over this topic.","title":"Where do I get the tile meshes from?"},{"location":"faq/#can-i-contribute","text":"The package itself is feature complete and I would like to keep the amount of contributors to a minimum so in most cases the answer is no. To avoid bloating the package itself new features are intended to be added as modules (check the documentation and the WorldMapSample to get a genreal idea). If you require some larger scale modifications to the source please create a fork instead.","title":"Can I contribute?"},{"location":"faq/#i-created-something-using-the-package-custom-module-or-game","text":"Feel free to drop me a message (mail is at the bottom of my portfolio page) and I will give you a shoutout in the documentation.","title":"I created something using the package? (custom module or game)"},{"location":"getting-started/","text":"Getting started Install instructions Start a new Unity Project and navigate to the Package Manager (Window > Package Manager). Open the [+] dropdown and select \"Add package from git URL ...\". The URL is the adress of this repository. Please refer to the documentation for it's usage. Install the sample project for a usecase example. Setting up your first map Create an empty gameobject and select [AddComponent > Tilemap3D] . You will be greeted with the interface above (the modules list will be empty). Start by deciding on the grid size (width height and depth of a single tile) and the map size. Map size can be changed later but keep in mind that map tile data culled in the process will be lost forever. Lastly you can find the module list. Start by clicking the little at the bottom and choose a TilemapMesh module. Painted tiles should now be visible. Setting up your tiles The topic on how to set up tiles is discussed on the next sub page. If this is your first time using the tool you can use the included samples which already have pre set up tiles available. With our map set up our next step will be to add some tiles to our palette. In the Unity menu bar navigate to [Window > TileExplorer] . This will open up a small window that can be docked anywhere inside the editor environment. The explorer will always show the palette of the current selected map so make sure to select the gameobject holding ours (if you created the map with the explorer open you need to deselect and reselect the map to refresh). To add new Tiles to the palette simply drag and drop tiles from your project browser into the palette (one tile at a time). Tiles inside the palette also have a right click menu that allows deleting or swapping them out. Once we have a collection of tiles ready the current painting index can be selected by clicking the desired tile inside the grid. Info Don't have any tiles? Either try using the ones that are provided in the sample project or refer to the page \"tile-setup\" for how to make your own Navigating the scene view If a valid map is selected the scene view inside Unity should display a new grid. This grid is used to determine on which layer our tiles are painted. The painting feature is based on dragging out boxes so let's start by clicking somewhere on the map and dragging out a selection. Once the right mouse button is released our tiles will be placed. The whole tool is navigated by a few key combos. Input mapping Input Action Right click Place tile (hold for dragging out a box) Right click + Shift Delete tile. (hold for dragging out a box) Left click + Shift Pick a tile W Key Move grid up one layer S Key Move grid down one layer A Key Rotate tile clockwise D Key Rotate tile counter clockwise A Key + Shift Move to the previous tile variation (if available) D Key + Shift Move to the next tile variation (if available) Warning Sometimes Unity messes with the key focus. In that case simply refresh by tapping middle mouse or left click and try again. Toolbar The tool also comes with it's own toolbar. If the toolbar does not show press the space key somewhere in the scene view and select [Tilemap-Brush] in the popup. The toolbar panel can be docked anywhere inside the interface. It consists of three elements: Grid: This doubles as a toggle to show or hide the tilemap grid and a dropdown. You can change the major axis (useful if working on a 2.5d map) or how the brush is previewed. While the Material preview is more accurate Shape can be seen through the map. Tile: The second dropdown can be used to manualy set the brushes settings in case you are not able to use the earlier input mappings. Additionaly you can find an option for tile randomization. Just don't forget to turn it off again once you are done. Flags: Lastly we have a list of registered flags which are written into the painted tiles. The package only uses two of the eight available spaces for it's auto tiling. By using either of them you can force different tiles to behave as if they have the same source. That's it for the basic introduction. Please refer to the other pages for a detailed explanation of the modules and tiles. If you encounter any tool breaking bugs that are not mentioned inside the documentation please open an issue on the github page.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#install-instructions","text":"Start a new Unity Project and navigate to the Package Manager (Window > Package Manager). Open the [+] dropdown and select \"Add package from git URL ...\". The URL is the adress of this repository. Please refer to the documentation for it's usage. Install the sample project for a usecase example.","title":"Install instructions"},{"location":"getting-started/#setting-up-your-first-map","text":"Create an empty gameobject and select [AddComponent > Tilemap3D] . You will be greeted with the interface above (the modules list will be empty). Start by deciding on the grid size (width height and depth of a single tile) and the map size. Map size can be changed later but keep in mind that map tile data culled in the process will be lost forever. Lastly you can find the module list. Start by clicking the little at the bottom and choose a TilemapMesh module. Painted tiles should now be visible.","title":"Setting up your first map"},{"location":"getting-started/#setting-up-your-tiles","text":"The topic on how to set up tiles is discussed on the next sub page. If this is your first time using the tool you can use the included samples which already have pre set up tiles available. With our map set up our next step will be to add some tiles to our palette. In the Unity menu bar navigate to [Window > TileExplorer] . This will open up a small window that can be docked anywhere inside the editor environment. The explorer will always show the palette of the current selected map so make sure to select the gameobject holding ours (if you created the map with the explorer open you need to deselect and reselect the map to refresh). To add new Tiles to the palette simply drag and drop tiles from your project browser into the palette (one tile at a time). Tiles inside the palette also have a right click menu that allows deleting or swapping them out. Once we have a collection of tiles ready the current painting index can be selected by clicking the desired tile inside the grid. Info Don't have any tiles? Either try using the ones that are provided in the sample project or refer to the page \"tile-setup\" for how to make your own","title":"Setting up your tiles"},{"location":"getting-started/#navigating-the-scene-view","text":"If a valid map is selected the scene view inside Unity should display a new grid. This grid is used to determine on which layer our tiles are painted. The painting feature is based on dragging out boxes so let's start by clicking somewhere on the map and dragging out a selection. Once the right mouse button is released our tiles will be placed. The whole tool is navigated by a few key combos.","title":"Navigating the scene view"},{"location":"getting-started/#input-mapping","text":"Input Action Right click Place tile (hold for dragging out a box) Right click + Shift Delete tile. (hold for dragging out a box) Left click + Shift Pick a tile W Key Move grid up one layer S Key Move grid down one layer A Key Rotate tile clockwise D Key Rotate tile counter clockwise A Key + Shift Move to the previous tile variation (if available) D Key + Shift Move to the next tile variation (if available) Warning Sometimes Unity messes with the key focus. In that case simply refresh by tapping middle mouse or left click and try again.","title":"Input mapping"},{"location":"getting-started/#toolbar","text":"The tool also comes with it's own toolbar. If the toolbar does not show press the space key somewhere in the scene view and select [Tilemap-Brush] in the popup. The toolbar panel can be docked anywhere inside the interface. It consists of three elements: Grid: This doubles as a toggle to show or hide the tilemap grid and a dropdown. You can change the major axis (useful if working on a 2.5d map) or how the brush is previewed. While the Material preview is more accurate Shape can be seen through the map. Tile: The second dropdown can be used to manualy set the brushes settings in case you are not able to use the earlier input mappings. Additionaly you can find an option for tile randomization. Just don't forget to turn it off again once you are done. Flags: Lastly we have a list of registered flags which are written into the painted tiles. The package only uses two of the eight available spaces for it's auto tiling. By using either of them you can force different tiles to behave as if they have the same source. That's it for the basic introduction. Please refer to the other pages for a detailed explanation of the modules and tiles. If you encounter any tool breaking bugs that are not mentioned inside the documentation please open an issue on the github page.","title":"Toolbar"},{"location":"modules/","text":"Modules Overview Modules are used to determine how the given map data is processed. They are component based and can therefore be directly added to child gameobjects of a Tilemap component. An easier way to add them is via the module list inside the inspector of said component. The module list also allows for quick baking of the modules but there are some options only visible when selecting the components directly. Tilemap Mesh Module for baking the mesh. It uses Unitys job system together with the tile list and data to generate the visual representation. The mesh module has two settings: Chunk Size: This option allows splitting large tilemaps into multiple game objects which can then each be culled individually. Using a value of 0 or below will cause the tilemap to not generate any sub chunks on the given axis. Values are in grid units. Hit bake and you can see the sub objects being generated as children. Vertex Info: Opening this foldout will reveal a bunch of available vertex data types. The underlying algorithm will only copy ticked data from it's tile meshes. It is highly reccomended to only tick boxes you will need on your final mesh since each additional attribute will also increase the size the mesh will take inside the memory. Tilemap Collider This module will use the available collision data set inside the tiles to generate an optimized collider. It will only generate manually when hitting the bake button on the component or inside the maps module list. It is highly reccomeded to rely on as many box colliders as possible since the underlying algorithm will sweep over them and combine them into multiple bigger boxes. Mesh colliders on the other hand will be copied one at a time since Unitys Mesh Collider type does not offer any option to offset them and combining the meshes would cause their bounding box to grow much larger. If tiles have different layer masks the resulting colliders will be placed on seperrate game objects. If the components gameobject is set to static all colliders will also be set to static. Tilemap Navigator This module is used to bake a Unity NavMesh from the tilemap data. The component will use tiles with collision types of Box, MeshBounds, MeshConvex and MeshComplex only. Like with the collision the baking process has to be called manualy. The module has a few settings: Agent Type: The NavMesh generation will refer to the coresponding agent settings from Unitys navigation window. Try adding your own or modify the default one. Generation Settings: Additionaly you can provide a number of generation related settings in the foldout. Refer to the page NavMeshBuildSettings inside of Unitys official documentation if you want to know what each setting does. Navigation Links: Since Unitys component based NavOffLinks did not work with the generated NavMesh this module instead provides it's own way to generate said links. Use the + button on the list to add a new link. Each link consinsts of the following options: Area dropdown (the color rect) to select one of the set up areas of the navigation window. Traveling cost will be taken from the coresponding area. Two tripplets of coordinates representing the start and end position of the link in grid space. Toggle button between the coordinates signaling if the link can be traveled in both directions. Navigation links are also visualized in the scene view where it is also possible to select their start and end point and move it around. The actual generated links are only available at runtime which enables the the component to clean them up when they are no longer needed. Known \"issues\" There is a list of things that can go wrong when using the modules in unintended ways. These are either hard to fix or would have an unecessary impact on performance: When copy pasting a whole map temporary references are also copied. This means editing will also update the old one. To fix this simply delete and readd the modules after duplication You might encounter null pointer exception when deleting generated sub modules by hand. These have cached elements for consecutive rebuilding. Please do not clear them by hand and instead either use the clear button or delete the whole module When updating some components at runtime you might run into an error regarding the meshes. A lot of performed operations require a tick in the checkbox \"Read/Write\" in the mesh importer The collider component is unfit for consecutive runtime refreshes. Unitys colliders are components so it has to create and destroy quite a few of them. If you need a more dynamic solution either look into Unitys Job based physics or create your own logic (full tile collision could easily be implemented by checking directly against the Tilemap.Data array) There is no tile specific navigation or pathfinding in Unitys NavMesh. If you need a more tile based algorithm you can try implementing an A* approach","title":"Modules"},{"location":"modules/#modules","text":"","title":"Modules"},{"location":"modules/#overview","text":"Modules are used to determine how the given map data is processed. They are component based and can therefore be directly added to child gameobjects of a Tilemap component. An easier way to add them is via the module list inside the inspector of said component. The module list also allows for quick baking of the modules but there are some options only visible when selecting the components directly.","title":"Overview"},{"location":"modules/#tilemap-mesh","text":"Module for baking the mesh. It uses Unitys job system together with the tile list and data to generate the visual representation. The mesh module has two settings: Chunk Size: This option allows splitting large tilemaps into multiple game objects which can then each be culled individually. Using a value of 0 or below will cause the tilemap to not generate any sub chunks on the given axis. Values are in grid units. Hit bake and you can see the sub objects being generated as children. Vertex Info: Opening this foldout will reveal a bunch of available vertex data types. The underlying algorithm will only copy ticked data from it's tile meshes. It is highly reccomended to only tick boxes you will need on your final mesh since each additional attribute will also increase the size the mesh will take inside the memory.","title":"Tilemap Mesh"},{"location":"modules/#tilemap-collider","text":"This module will use the available collision data set inside the tiles to generate an optimized collider. It will only generate manually when hitting the bake button on the component or inside the maps module list. It is highly reccomeded to rely on as many box colliders as possible since the underlying algorithm will sweep over them and combine them into multiple bigger boxes. Mesh colliders on the other hand will be copied one at a time since Unitys Mesh Collider type does not offer any option to offset them and combining the meshes would cause their bounding box to grow much larger. If tiles have different layer masks the resulting colliders will be placed on seperrate game objects. If the components gameobject is set to static all colliders will also be set to static.","title":"Tilemap Collider"},{"location":"modules/#tilemap-navigator","text":"This module is used to bake a Unity NavMesh from the tilemap data. The component will use tiles with collision types of Box, MeshBounds, MeshConvex and MeshComplex only. Like with the collision the baking process has to be called manualy. The module has a few settings: Agent Type: The NavMesh generation will refer to the coresponding agent settings from Unitys navigation window. Try adding your own or modify the default one. Generation Settings: Additionaly you can provide a number of generation related settings in the foldout. Refer to the page NavMeshBuildSettings inside of Unitys official documentation if you want to know what each setting does. Navigation Links: Since Unitys component based NavOffLinks did not work with the generated NavMesh this module instead provides it's own way to generate said links. Use the + button on the list to add a new link. Each link consinsts of the following options: Area dropdown (the color rect) to select one of the set up areas of the navigation window. Traveling cost will be taken from the coresponding area. Two tripplets of coordinates representing the start and end position of the link in grid space. Toggle button between the coordinates signaling if the link can be traveled in both directions. Navigation links are also visualized in the scene view where it is also possible to select their start and end point and move it around. The actual generated links are only available at runtime which enables the the component to clean them up when they are no longer needed.","title":"Tilemap Navigator"},{"location":"modules/#known-issues","text":"There is a list of things that can go wrong when using the modules in unintended ways. These are either hard to fix or would have an unecessary impact on performance: When copy pasting a whole map temporary references are also copied. This means editing will also update the old one. To fix this simply delete and readd the modules after duplication You might encounter null pointer exception when deleting generated sub modules by hand. These have cached elements for consecutive rebuilding. Please do not clear them by hand and instead either use the clear button or delete the whole module When updating some components at runtime you might run into an error regarding the meshes. A lot of performed operations require a tick in the checkbox \"Read/Write\" in the mesh importer The collider component is unfit for consecutive runtime refreshes. Unitys colliders are components so it has to create and destroy quite a few of them. If you need a more dynamic solution either look into Unitys Job based physics or create your own logic (full tile collision could easily be implemented by checking directly against the Tilemap.Data array) There is no tile specific navigation or pathfinding in Unitys NavMesh. If you need a more tile based algorithm you can try implementing an A* approach","title":"Known \"issues\""},{"location":"samples/","text":"Samples PixelMapSample Shows basic usage of the included tools Includes a custom character controller for testing the different features Navigation scene shows how to use the navigator component to build a NavMesh 2D scene focues on setting up tiles on the XY axis Includes a shader to show an example for animated tiles (via uv offset) (New) Simple example for generating dungeons from map prefabs WorldMapSample Shows implementation of a custom tile type and module (Prefab based) Features an example of modifying the tilemap at runtime (select building and hit the delete key) Features a procedural runtime generation example (hit the R key to generate)","title":"Samples"},{"location":"samples/#samples","text":"","title":"Samples"},{"location":"samples/#pixelmapsample","text":"Shows basic usage of the included tools Includes a custom character controller for testing the different features Navigation scene shows how to use the navigator component to build a NavMesh 2D scene focues on setting up tiles on the XY axis Includes a shader to show an example for animated tiles (via uv offset) (New) Simple example for generating dungeons from map prefabs","title":"PixelMapSample"},{"location":"samples/#worldmapsample","text":"Shows implementation of a custom tile type and module (Prefab based) Features an example of modifying the tilemap at runtime (select building and hit the delete key) Features a procedural runtime generation example (hit the R key to generate)","title":"WorldMapSample"},{"location":"tiles/","text":"Tiles Creating Tile Meshes For this section I assume you are somewhat familiar with 3D modelling tools and importing assets into Unity. Tiles should match the grid size within the tilemap (1x1x1unit tile should also have those bounds for the mesh) Pivots are always in the center of the gridsize. A 1m tile would have it's pivot at 0.5m. Tiles can go outside of their bounds in which case the pivot should be the center of the lowest tile element. The recommended orientation for the tiles should be how a corner would match a transform gizmo (borders on X and Z and Y up). Make sure meshes are imported with their Y axis facing up and Z axis forward since the tool will not fix your rotation for you. Info Skeletal or shapekey animations are not supported! They would be very expensive in a combined mesh. Please consider animations via gameobjects or a shader using either an uv offset loop or vertex color offsets. Adding Tiles Right click in your project browser and choose [MapTool > TileType] . Type Usage Single Basic tile Multi Supports variations for a clean grouping of tiles in the browser Auto Sub tiles that get choosen depending on their neighbours General tile settings Each tile has a number of default settings that need to be configured. Materials are shared by all the sub variations of a tile. The same goes for collision layer and the NavMesh specific Navigation Area. Next up we have the Tile Information. On a single tile you have one while on multi and auto tiles you have a list of them (auto tile has an additional mask per tile). Info The preview at the bottom of the inspector always shows the currently selected tile variation. You can use the small gizmo in it's corner to rotate it or left click the gizmo to choose from a selection of pre set orientations. The orientation of the preview will also be used for the tile icon in the tile explorer. Collider types Type Usage None No collision Box Full tile collision. Should be choosen most of the time for optimal collider performance Box extend Full tile collision that extends upwards until it hits another tile Mesh bounds Generates a box using Mesh.bounds as it's size. Optimal for objects that are mostly cubic Mesh convex Uses collision mesh but ticks the convex option to make it more performant Mesh complex Worst option but sometimes needed. Uses the collision mesh as it is Auto Tiles and Tile masks Auto tiles supports both 4bit masks or 8bit masks (with corners) settable by a dropdown above the tile list. The Tile mask also includes a dropdown for tilemask rotations to reuse the same mesh over multiple directions. The more unique variations are required (corners / patterns) the more sub tiles you will need to configure (Worst case is 53 variations for no rotation 8bit mask). Sub variations within auto tiling are not supported due to the complexity. They can still be added via merge flags though. Type Usage Single No rotation masks Rotated Masks for 90\u00b0 / 180\u00b0 / 270\u00b0 rotation Flip Mask for 180\u00b0 rotation Warning When setting up a 4bit mask do not tick the diagonals. If you set up an 8 bit mask do not tick diagonals without ticked neighbours. These variations would always be optional and therefore are excluded from the algorithm. As the mask itself is used to pick the tile (for quicker lookup) they would never be choosen. Auto tile settings Border behaviour (how does a tile behave at the edge of a map) Orientation (only swap if tiles are intended to be used for a sideway 2.5d map) Merge flag behaviour (can be used to overwrite the flag rules for only this tile for \"inner\" auto tiles that are used on the inside of others) Optimization tips Use a texture atlas for your tiles instead of giving all of them their own texture / material. Tiles that share the same material can be combined into a single submesh. If you still need a custom material for a specific tile (example: transparent water) it will become it's own sub mesh later on. Try to stay relativly low poly. The algorithm won't merge tiles at their border points (and can't anyways due to their differences in uv coordinates). This means vertex count optimizations have to happen within the tiles mesh. If all of your tiles don't need normals / tangents / colors cosider turning them off in the mesh module. Consider using inbetween layer variations for muti high tiles that don't include the top part to reduce the total vertex count. Autotiles can be merged via flag so you can still have them on the same layer. If you have slopes or other geometry that would require mesh colliders consider preparing one in blender by hand. That way you can exactly control how many faces the end product has. Consider adding overlay type of tiles (like paths) as zero collision tiles on the layer above the floor. That way they can also overlay borders and corners which would otherwise interfere.","title":"Tiles"},{"location":"tiles/#tiles","text":"","title":"Tiles"},{"location":"tiles/#creating-tile-meshes","text":"For this section I assume you are somewhat familiar with 3D modelling tools and importing assets into Unity. Tiles should match the grid size within the tilemap (1x1x1unit tile should also have those bounds for the mesh) Pivots are always in the center of the gridsize. A 1m tile would have it's pivot at 0.5m. Tiles can go outside of their bounds in which case the pivot should be the center of the lowest tile element. The recommended orientation for the tiles should be how a corner would match a transform gizmo (borders on X and Z and Y up). Make sure meshes are imported with their Y axis facing up and Z axis forward since the tool will not fix your rotation for you. Info Skeletal or shapekey animations are not supported! They would be very expensive in a combined mesh. Please consider animations via gameobjects or a shader using either an uv offset loop or vertex color offsets.","title":"Creating Tile Meshes"},{"location":"tiles/#adding-tiles","text":"Right click in your project browser and choose [MapTool > TileType] . Type Usage Single Basic tile Multi Supports variations for a clean grouping of tiles in the browser Auto Sub tiles that get choosen depending on their neighbours","title":"Adding Tiles"},{"location":"tiles/#general-tile-settings","text":"Each tile has a number of default settings that need to be configured. Materials are shared by all the sub variations of a tile. The same goes for collision layer and the NavMesh specific Navigation Area. Next up we have the Tile Information. On a single tile you have one while on multi and auto tiles you have a list of them (auto tile has an additional mask per tile). Info The preview at the bottom of the inspector always shows the currently selected tile variation. You can use the small gizmo in it's corner to rotate it or left click the gizmo to choose from a selection of pre set orientations. The orientation of the preview will also be used for the tile icon in the tile explorer.","title":"General tile settings"},{"location":"tiles/#collider-types","text":"Type Usage None No collision Box Full tile collision. Should be choosen most of the time for optimal collider performance Box extend Full tile collision that extends upwards until it hits another tile Mesh bounds Generates a box using Mesh.bounds as it's size. Optimal for objects that are mostly cubic Mesh convex Uses collision mesh but ticks the convex option to make it more performant Mesh complex Worst option but sometimes needed. Uses the collision mesh as it is","title":"Collider types"},{"location":"tiles/#auto-tiles-and-tile-masks","text":"Auto tiles supports both 4bit masks or 8bit masks (with corners) settable by a dropdown above the tile list. The Tile mask also includes a dropdown for tilemask rotations to reuse the same mesh over multiple directions. The more unique variations are required (corners / patterns) the more sub tiles you will need to configure (Worst case is 53 variations for no rotation 8bit mask). Sub variations within auto tiling are not supported due to the complexity. They can still be added via merge flags though. Type Usage Single No rotation masks Rotated Masks for 90\u00b0 / 180\u00b0 / 270\u00b0 rotation Flip Mask for 180\u00b0 rotation Warning When setting up a 4bit mask do not tick the diagonals. If you set up an 8 bit mask do not tick diagonals without ticked neighbours. These variations would always be optional and therefore are excluded from the algorithm. As the mask itself is used to pick the tile (for quicker lookup) they would never be choosen.","title":"Auto Tiles and Tile masks"},{"location":"tiles/#auto-tile-settings","text":"Border behaviour (how does a tile behave at the edge of a map) Orientation (only swap if tiles are intended to be used for a sideway 2.5d map) Merge flag behaviour (can be used to overwrite the flag rules for only this tile for \"inner\" auto tiles that are used on the inside of others)","title":"Auto tile settings"},{"location":"tiles/#optimization-tips","text":"Use a texture atlas for your tiles instead of giving all of them their own texture / material. Tiles that share the same material can be combined into a single submesh. If you still need a custom material for a specific tile (example: transparent water) it will become it's own sub mesh later on. Try to stay relativly low poly. The algorithm won't merge tiles at their border points (and can't anyways due to their differences in uv coordinates). This means vertex count optimizations have to happen within the tiles mesh. If all of your tiles don't need normals / tangents / colors cosider turning them off in the mesh module. Consider using inbetween layer variations for muti high tiles that don't include the top part to reduce the total vertex count. Autotiles can be merged via flag so you can still have them on the same layer. If you have slopes or other geometry that would require mesh colliders consider preparing one in blender by hand. That way you can exactly control how many faces the end product has. Consider adding overlay type of tiles (like paths) as zero collision tiles on the layer above the floor. That way they can also overlay borders and corners which would otherwise interfere.","title":"Optimization tips"},{"location":"api/AutoTile/","text":"AutoTile Class describing a tile using multiple variants to create borders. Properties Type Name Usage TileInfoMask[] Variants Collection of sub tiles using TileMasks int Length Sub tile count bool EightBitMask Does the algorithm use eight or four directions bool NoBorder Merges tiles with the border bool Orientation2D Is the algorithm processing the XY layer instead of XZ bool Isloate Ignore tile flags and never merge to other tiles Inherited Properties Type Name Usage Material Material Shared material of all tile meshes int CollisionLayer Layer generated colliders are put on int NavigationArea Area for NavMesh generation TileInfo this[int] Indexer to GetInfo() Vector2 PreviewOrientation Orientation of generated previews Quatenrion PreviewRotation PreviewOrientation as Quaternion Methods Name Usage GetInfo(int index) Get sub tile at sub tile index GetTilePreview(int index) Always returns first variant PostProcessTile(TilemapData data, int3 pos) Fix data via auto tiling algorithm","title":"AutoTile"},{"location":"api/AutoTile/#autotile","text":"Class describing a tile using multiple variants to create borders.","title":"AutoTile"},{"location":"api/AutoTile/#properties","text":"Type Name Usage TileInfoMask[] Variants Collection of sub tiles using TileMasks int Length Sub tile count bool EightBitMask Does the algorithm use eight or four directions bool NoBorder Merges tiles with the border bool Orientation2D Is the algorithm processing the XY layer instead of XZ bool Isloate Ignore tile flags and never merge to other tiles","title":"Properties"},{"location":"api/AutoTile/#inherited-properties","text":"Type Name Usage Material Material Shared material of all tile meshes int CollisionLayer Layer generated colliders are put on int NavigationArea Area for NavMesh generation TileInfo this[int] Indexer to GetInfo() Vector2 PreviewOrientation Orientation of generated previews Quatenrion PreviewRotation PreviewOrientation as Quaternion","title":"Inherited Properties"},{"location":"api/AutoTile/#methods","text":"Name Usage GetInfo(int index) Get sub tile at sub tile index GetTilePreview(int index) Always returns first variant PostProcessTile(TilemapData data, int3 pos) Fix data via auto tiling algorithm","title":"Methods"},{"location":"api/BaseTile/","text":"BaseTile Base class for all tiles. Inherit from it if you plan to add a custom tile. Properties Type Name Usage Material Material Shared material of all tile meshes int CollisionLayer Layer generated colliders are put on int NavigationArea Area for NavMesh generation TileInfo this[int] Indexer to GetInfo() int Length Amount of sub variants implemented by sub classes Vector2 PreviewOrientation Orientation of generated previews Quatenrion PreviewRotation PreviewOrientation as Quaternion Methods Name Usage GetInfo(int index) Get tile info at index. Implemented by sub classes GetTilePreview(int index) Get mesh preview. Implemented by sub classes PostProcessTile(TilemapData data, int3 pos) Run custom logic over a placed tile. Implemented by sub classes","title":"BaseTile"},{"location":"api/BaseTile/#basetile","text":"Base class for all tiles. Inherit from it if you plan to add a custom tile.","title":"BaseTile"},{"location":"api/BaseTile/#properties","text":"Type Name Usage Material Material Shared material of all tile meshes int CollisionLayer Layer generated colliders are put on int NavigationArea Area for NavMesh generation TileInfo this[int] Indexer to GetInfo() int Length Amount of sub variants implemented by sub classes Vector2 PreviewOrientation Orientation of generated previews Quatenrion PreviewRotation PreviewOrientation as Quaternion","title":"Properties"},{"location":"api/BaseTile/#methods","text":"Name Usage GetInfo(int index) Get tile info at index. Implemented by sub classes GetTilePreview(int index) Get mesh preview. Implemented by sub classes PostProcessTile(TilemapData data, int3 pos) Run custom logic over a placed tile. Implemented by sub classes","title":"Methods"},{"location":"api/ITilemapModule/","text":"ITilemapModule Interface for implementing modules. Should always be used in combination with Monobehaviour. Extend this class if you want to write a custom module. Methods Name Usage BakePartial(Tilemap3D map, Box3D area) Called when map is baked dynamicly Bake(Tilemap3D map) Called when map is baked Clear() Clean up module data on demand","title":"ITilemapModule"},{"location":"api/ITilemapModule/#itilemapmodule","text":"Interface for implementing modules. Should always be used in combination with Monobehaviour. Extend this class if you want to write a custom module.","title":"ITilemapModule"},{"location":"api/ITilemapModule/#methods","text":"Name Usage BakePartial(Tilemap3D map, Box3D area) Called when map is baked dynamicly Bake(Tilemap3D map) Called when map is baked Clear() Clean up module data on demand","title":"Methods"},{"location":"api/MultiTile/","text":"MultiTile Class describing a tile with multiple variants. Properties Type Name Usage TileInfo[] Variants Collection of sub tiles int Length Sub tile count Inherited Properties Type Name Usage Material Material Shared material of all tile meshes int CollisionLayer Layer generated colliders are put on int NavigationArea Area for NavMesh generation TileInfo this[int] Indexer to GetInfo() Vector2 PreviewOrientation Orientation of generated previews Quatenrion PreviewRotation PreviewOrientation as Quaternion Methods Name Usage GetInfo(int index) Get sub tile at sub tile index GetTilePreview(int index) Get preview mesh at sub tile index PostProcessTile(TilemapData data, int3 pos) Not implemented","title":"MultiTile"},{"location":"api/MultiTile/#multitile","text":"Class describing a tile with multiple variants.","title":"MultiTile"},{"location":"api/MultiTile/#properties","text":"Type Name Usage TileInfo[] Variants Collection of sub tiles int Length Sub tile count","title":"Properties"},{"location":"api/MultiTile/#inherited-properties","text":"Type Name Usage Material Material Shared material of all tile meshes int CollisionLayer Layer generated colliders are put on int NavigationArea Area for NavMesh generation TileInfo this[int] Indexer to GetInfo() Vector2 PreviewOrientation Orientation of generated previews Quatenrion PreviewRotation PreviewOrientation as Quaternion","title":"Inherited Properties"},{"location":"api/MultiTile/#methods","text":"Name Usage GetInfo(int index) Get sub tile at sub tile index GetTilePreview(int index) Get preview mesh at sub tile index PostProcessTile(TilemapData data, int3 pos) Not implemented","title":"Methods"},{"location":"api/SingleTile/","text":"SingleTile Class describing a tile without variants. Properties Type Name Usage TileInfo TileInfo Settings of the tile int Length Amount of sub variants. Always one Inherited Properties Type Name Usage Material Material Shared material of all tile meshes int CollisionLayer Layer generated colliders are put on int NavigationArea Area for NavMesh generation TileInfo this[int] Indexer to GetInfo() Vector2 PreviewOrientation Orientation of generated previews Quatenrion PreviewRotation PreviewOrientation as Quaternion Methods Name Usage GetInfo(int index) Always points at TileInfo GetTilePreview(int index) TileInfo.Mesh PostProcessTile(TilemapData data, int3 pos) Not implemented","title":"SingleTile"},{"location":"api/SingleTile/#singletile","text":"Class describing a tile without variants.","title":"SingleTile"},{"location":"api/SingleTile/#properties","text":"Type Name Usage TileInfo TileInfo Settings of the tile int Length Amount of sub variants. Always one","title":"Properties"},{"location":"api/SingleTile/#inherited-properties","text":"Type Name Usage Material Material Shared material of all tile meshes int CollisionLayer Layer generated colliders are put on int NavigationArea Area for NavMesh generation TileInfo this[int] Indexer to GetInfo() Vector2 PreviewOrientation Orientation of generated previews Quatenrion PreviewRotation PreviewOrientation as Quaternion","title":"Inherited Properties"},{"location":"api/SingleTile/#methods","text":"Name Usage GetInfo(int index) Always points at TileInfo GetTilePreview(int index) TileInfo.Mesh PostProcessTile(TilemapData data, int3 pos) Not implemented","title":"Methods"},{"location":"api/TilePalette/","text":"TilePalette Class for holding BaseTile data inside an array. Maximum amout of tiles is 255 since the zero id is reserved for empty tiles. Generally I will not reccomend messing with the array to much but you might need to if you plan to implement a runtime editor. Properties Type Name Usage BaseTile this[int] Indexer to BaseTile array int Count How many active tiles are inside the array Methods Name Usage TilePalette() Constructor TilePalette(BaseTile[] entries) Special constructor creating the palette from a collection (recommended for runtime setup) Insert(BaseTile tile, int position, ref TilemapData data) Insert tile at position. Fixes map data to match changes. Returns true if rebuild is necessary Replace(BaseTile tile, int position) Replace tile at position. Returns true if rebuild is necessary Delete(int position, ref TilemapData data) Delete index at position. Fixes map data to match changes. Returns true if rebuild is necessary GetTile(int id) Get tile at id point. Will ignore zero ids since they represent empty spaces","title":"TilePalette"},{"location":"api/TilePalette/#tilepalette","text":"Class for holding BaseTile data inside an array. Maximum amout of tiles is 255 since the zero id is reserved for empty tiles. Generally I will not reccomend messing with the array to much but you might need to if you plan to implement a runtime editor.","title":"TilePalette"},{"location":"api/TilePalette/#properties","text":"Type Name Usage BaseTile this[int] Indexer to BaseTile array int Count How many active tiles are inside the array","title":"Properties"},{"location":"api/TilePalette/#methods","text":"Name Usage TilePalette() Constructor TilePalette(BaseTile[] entries) Special constructor creating the palette from a collection (recommended for runtime setup) Insert(BaseTile tile, int position, ref TilemapData data) Insert tile at position. Fixes map data to match changes. Returns true if rebuild is necessary Replace(BaseTile tile, int position) Replace tile at position. Returns true if rebuild is necessary Delete(int position, ref TilemapData data) Delete index at position. Fixes map data to match changes. Returns true if rebuild is necessary GetTile(int id) Get tile at id point. Will ignore zero ids since they represent empty spaces","title":"Methods"},{"location":"api/Tilemap3D/","text":"Tilemap3D Main component for tilemap generation. Use Data modification in combination with one of the bake methods to update the map. Properties Type Name Usage TilePalette Palette Tile palette stored in the map TileMapData Data Map data. Read and write to it to modify the map float3 GridSize Size of a single cell. Should match the provided tile mesh size int Width Getter to Data.Width int Height Getter to Data.Height int Depth Getter to Data.Depth int3 Size Getter to Data.Size int Length Getter to Data.Length Box3D Area Local bounds of the map TileMapData.Tile this[int3] Indexer to Data[int3] ITilemapModule Modules Current list of tilemap modules in children Methods Name Usage BakeDynamic(Box3D area) Rebake dynamic module content within area BakeDynamic() Rebake dynamic module content for the whole map Bake() Bake static module content for the whole map RefreshModules() Force update to module list Tilemap3DUtility Static extension methods for Tilemap3D. Static Methods Name Usage GetLayerPlane(int axis, int layer) Calculate a local space plane on the given axis (0x-1y-2z) for the given layer RaycastLayer(this Tilemap3D map, Ray ray, Plane plane, out int3 hit) Raycast a local space plane. Input ray is in worldspace and will be transformed into grid space. Returns false if hit is outside bounds GridToWorld(this Tilemap3D map, int3 position, float3 pivot) Returns the map position at the given pivot (0-1 range) in world coordinates GridToWorld(this Tilemap3D map, int3 position) Returns the map position in world coordinates GridToLocal(this Tilemap3D map, int3 position, float3 pivot) Returns the map position at the given pivot (0-1 range) in local coordinates GridToLocal(this Tilemap3D map, int3 position) Returns the map position in local coordinates WorldToGrid(this Tilemap3D map, float3 position) Returns the map grid position at given world position (this includes out of bounds) ReconstructPosition(this Tilemap3D map, int index) Converts index into xyz coordinate InBounds(this Tilemap3D map, int3 position) Checks if the given grid coordinates are in bounds PostProcessTiles(this Tilemap3D map, Box3D area) Post processes area and it's neighbours. Returns the area containing it's neighbours","title":"Tilemap3D"},{"location":"api/Tilemap3D/#tilemap3d","text":"Main component for tilemap generation. Use Data modification in combination with one of the bake methods to update the map.","title":"Tilemap3D"},{"location":"api/Tilemap3D/#properties","text":"Type Name Usage TilePalette Palette Tile palette stored in the map TileMapData Data Map data. Read and write to it to modify the map float3 GridSize Size of a single cell. Should match the provided tile mesh size int Width Getter to Data.Width int Height Getter to Data.Height int Depth Getter to Data.Depth int3 Size Getter to Data.Size int Length Getter to Data.Length Box3D Area Local bounds of the map TileMapData.Tile this[int3] Indexer to Data[int3] ITilemapModule Modules Current list of tilemap modules in children","title":"Properties"},{"location":"api/Tilemap3D/#methods","text":"Name Usage BakeDynamic(Box3D area) Rebake dynamic module content within area BakeDynamic() Rebake dynamic module content for the whole map Bake() Bake static module content for the whole map RefreshModules() Force update to module list","title":"Methods"},{"location":"api/Tilemap3D/#tilemap3dutility","text":"Static extension methods for Tilemap3D.","title":"Tilemap3DUtility"},{"location":"api/Tilemap3D/#static-methods","text":"Name Usage GetLayerPlane(int axis, int layer) Calculate a local space plane on the given axis (0x-1y-2z) for the given layer RaycastLayer(this Tilemap3D map, Ray ray, Plane plane, out int3 hit) Raycast a local space plane. Input ray is in worldspace and will be transformed into grid space. Returns false if hit is outside bounds GridToWorld(this Tilemap3D map, int3 position, float3 pivot) Returns the map position at the given pivot (0-1 range) in world coordinates GridToWorld(this Tilemap3D map, int3 position) Returns the map position in world coordinates GridToLocal(this Tilemap3D map, int3 position, float3 pivot) Returns the map position at the given pivot (0-1 range) in local coordinates GridToLocal(this Tilemap3D map, int3 position) Returns the map position in local coordinates WorldToGrid(this Tilemap3D map, float3 position) Returns the map grid position at given world position (this includes out of bounds) ReconstructPosition(this Tilemap3D map, int index) Converts index into xyz coordinate InBounds(this Tilemap3D map, int3 position) Checks if the given grid coordinates are in bounds PostProcessTiles(this Tilemap3D map, Box3D area) Post processes area and it's neighbours. Returns the area containing it's neighbours","title":"Static Methods"},{"location":"api/TilemapCollider/","text":"TilemapCollider Module component for generating collider components from TilePalette and TileMapData information. Will combine adjacent box colliders into bigger boxes. Should only be called sparsly due to the baking process generating a lot of components. Inherited Methods Name Usage BakePartial(Tilemap3D map, Box3D area) Unused Bake(Tilemap3D map) Bake box and mesh colliders to sub objects Clear() Clear generated sub objects","title":"TilemapCollider"},{"location":"api/TilemapCollider/#tilemapcollider","text":"Module component for generating collider components from TilePalette and TileMapData information. Will combine adjacent box colliders into bigger boxes. Should only be called sparsly due to the baking process generating a lot of components.","title":"TilemapCollider"},{"location":"api/TilemapCollider/#inherited-methods","text":"Name Usage BakePartial(Tilemap3D map, Box3D area) Unused Bake(Tilemap3D map) Bake box and mesh colliders to sub objects Clear() Clear generated sub objects","title":"Inherited Methods"},{"location":"api/TilemapData/","text":"TilemapData Struct holding the tilemap data inside a one dimensional int array. The array can be accessed via a set of methods. Properties Type Name Usage int Width Width of the volume int Height Height of the volume int Depth Depth of the volume int3 Size Width height and depth of the volume int Length Length of the data array TileMapData.Tile this[int, int, int] Indexer to data from coordinate tripplet TileMapData.Tile this[int3] Indexer to data from int3 TileMapData.Tile this[int] Indexer directly to raw data array Methods Name Usage TilemapData(int width, int height, int depth) Constructor GetIndex(int x, int y, int z) Convert position to array index InRange(int x, int y, int z) Check if position is inside volume InRange(int index) Check if index is inside data array Resize(int width, int height, int depth) Resize the data volume while maintaining content TilemapData.Tile Helper struct to convert stored integer into four bytes. Properties Type Name Usage byte id Index of the tile data. Zero index means empty tile byte variant Subvariant of the given index byte rotation Rotation between 0-3 byte flags Aditional bitflags stored inside a byte Methods Name Usage GetFlags() Get flags as TileFlags bit mask HasFlag(TileFlags flag) Check if the tile has the given flag. Returns bool GetRotation() Get rotation as a quaternion TilemapDataUtility Static extension methods for TilemapData. Static Methods Name Usage CopyData(this TilemapData target, TilemapData source, int3 pos) Copy data from source to target starting at the set position ClearArea(this TilemapData data, int3 pos, int3 size) Clear all data in the given area Clear(this TilemapData data) Clear the whole TilemapData array","title":"TilemapData"},{"location":"api/TilemapData/#tilemapdata","text":"Struct holding the tilemap data inside a one dimensional int array. The array can be accessed via a set of methods.","title":"TilemapData"},{"location":"api/TilemapData/#properties","text":"Type Name Usage int Width Width of the volume int Height Height of the volume int Depth Depth of the volume int3 Size Width height and depth of the volume int Length Length of the data array TileMapData.Tile this[int, int, int] Indexer to data from coordinate tripplet TileMapData.Tile this[int3] Indexer to data from int3 TileMapData.Tile this[int] Indexer directly to raw data array","title":"Properties"},{"location":"api/TilemapData/#methods","text":"Name Usage TilemapData(int width, int height, int depth) Constructor GetIndex(int x, int y, int z) Convert position to array index InRange(int x, int y, int z) Check if position is inside volume InRange(int index) Check if index is inside data array Resize(int width, int height, int depth) Resize the data volume while maintaining content","title":"Methods"},{"location":"api/TilemapData/#tilemapdatatile","text":"Helper struct to convert stored integer into four bytes.","title":"TilemapData.Tile"},{"location":"api/TilemapData/#properties_1","text":"Type Name Usage byte id Index of the tile data. Zero index means empty tile byte variant Subvariant of the given index byte rotation Rotation between 0-3 byte flags Aditional bitflags stored inside a byte","title":"Properties"},{"location":"api/TilemapData/#methods_1","text":"Name Usage GetFlags() Get flags as TileFlags bit mask HasFlag(TileFlags flag) Check if the tile has the given flag. Returns bool GetRotation() Get rotation as a quaternion","title":"Methods"},{"location":"api/TilemapData/#tilemapdatautility","text":"Static extension methods for TilemapData.","title":"TilemapDataUtility"},{"location":"api/TilemapData/#static-methods","text":"Name Usage CopyData(this TilemapData target, TilemapData source, int3 pos) Copy data from source to target starting at the set position ClearArea(this TilemapData data, int3 pos, int3 size) Clear all data in the given area Clear(this TilemapData data) Clear the whole TilemapData array","title":"Static Methods"},{"location":"api/TilemapGUIUtility/","text":"TilemapGUIUtility (Editor only) A static helper class to draw commonly used GUI elements. Static Methods Name Usage AreaPopup(string labelName, SerializedProperty areaProperty) Popup type for navigation areas AreaColorField(Rect rect, SerializedProperty areaProperty) Popup type for navigation areas using the area color AgentTypePopup(string labelName, SerializedProperty agentTypeID) Popup type for navigation agents GetNavigationAreaColor(int i) Unity internal calculation of navigation area color ToolbarField(GUIContent label, int value, GUIContent[] options) Displays a toolbar like a field ToolbarToggleField(GUIContent label, bool value, GUIContent[] options) Draws a toggle as a toolbar (requires exactly 2 options in array) ToolbarTogglePopup(GUIContent label, bool value, GUIContent[] options) Draws a toggle as a popup (requires exactly 2 options in array) ShowBakeOptions<ITilemapModule>(ITilemapModule obj, bool clearingDisabled, bool bakingDisabled) Shared module buttons","title":"TilemapGUIUtility"},{"location":"api/TilemapGUIUtility/#tilemapguiutility-editor-only","text":"A static helper class to draw commonly used GUI elements.","title":"TilemapGUIUtility (Editor only)"},{"location":"api/TilemapGUIUtility/#static-methods","text":"Name Usage AreaPopup(string labelName, SerializedProperty areaProperty) Popup type for navigation areas AreaColorField(Rect rect, SerializedProperty areaProperty) Popup type for navigation areas using the area color AgentTypePopup(string labelName, SerializedProperty agentTypeID) Popup type for navigation agents GetNavigationAreaColor(int i) Unity internal calculation of navigation area color ToolbarField(GUIContent label, int value, GUIContent[] options) Displays a toolbar like a field ToolbarToggleField(GUIContent label, bool value, GUIContent[] options) Draws a toggle as a toolbar (requires exactly 2 options in array) ToolbarTogglePopup(GUIContent label, bool value, GUIContent[] options) Draws a toggle as a popup (requires exactly 2 options in array) ShowBakeOptions<ITilemapModule>(ITilemapModule obj, bool clearingDisabled, bool bakingDisabled) Shared module buttons","title":"Static Methods"},{"location":"api/TilemapMesh/","text":"TilemapMesh Module component for generating a mesh from TilePalette and TileMapData information. Properties Type Name Usage int3 ChunkSize Size of chunk in grid units. Zero or smaller results in the max of the dimension VertexSettings VertexInfo Included attributes in baking process Inherited Methods Name Usage BakePartial(Tilemap3D map, Box3D area) Bake mesh information in overlapping chunks Bake(Tilemap3D map) Full rebake of all chunks Clear() Unused","title":"TilemapMesh"},{"location":"api/TilemapMesh/#tilemapmesh","text":"Module component for generating a mesh from TilePalette and TileMapData information.","title":"TilemapMesh"},{"location":"api/TilemapMesh/#properties","text":"Type Name Usage int3 ChunkSize Size of chunk in grid units. Zero or smaller results in the max of the dimension VertexSettings VertexInfo Included attributes in baking process","title":"Properties"},{"location":"api/TilemapMesh/#inherited-methods","text":"Name Usage BakePartial(Tilemap3D map, Box3D area) Bake mesh information in overlapping chunks Bake(Tilemap3D map) Full rebake of all chunks Clear() Unused","title":"Inherited Methods"},{"location":"api/TilemapNavigator/","text":"TilemapNavigator Module component for generating a NavMesh from TilemapData and Tile colliders. Properties Type Name Usage int AgentPreset Gather build settings from Navigation window preset NavGenerationSettings GenerationSettings Additional settings. Refer to NavMeshBuildSettings in Unitys documentation NavLink NavLinks Set Area, Start, End and Directionality of navigation links. The actual links are generated at runtime Inherited Methods Name Usage BakePartial(Tilemap3D map, Box3D area) Unused Bake(Tilemap3D map) Bake Unity NavMesh from tile information Clear() Clear NavMesh","title":"TilemapNavigator"},{"location":"api/TilemapNavigator/#tilemapnavigator","text":"Module component for generating a NavMesh from TilemapData and Tile colliders.","title":"TilemapNavigator"},{"location":"api/TilemapNavigator/#properties","text":"Type Name Usage int AgentPreset Gather build settings from Navigation window preset NavGenerationSettings GenerationSettings Additional settings. Refer to NavMeshBuildSettings in Unitys documentation NavLink NavLinks Set Area, Start, End and Directionality of navigation links. The actual links are generated at runtime","title":"Properties"},{"location":"api/TilemapNavigator/#inherited-methods","text":"Name Usage BakePartial(Tilemap3D map, Box3D area) Unused Bake(Tilemap3D map) Bake Unity NavMesh from tile information Clear() Clear NavMesh","title":"Inherited Methods"},{"location":"api/TilemapSettings/","text":"TilemapSettings (Editor only) Settings object that gets stored in ProjectRoot/UserSettings. Save serialization is called when switching away from an active tilemap. Values are mainly modified by package interfaces but can be freely set for extensions as well. Properties Type Name Usage int Index Active index of the cursor (zero is empty) int Variant Active sub index of the cursor int Rotation Active rotation of the cursor (0-3) TileFlags Flags Active flags of the cursor bool ShowGrid Shows or hides the grid int GridLayer Active working layer of the grid int GridAxis Display axis of the grid (0=x 1=y 2=z) float3 GridSize Size of a single cell. Should match the provided tile mesh size bool PreviewMode Toggles between shape and textured preview int Randomizer Tile placing setting (0=none 1=variant 2=rotation 3=both) float ExplorerTileSize Display size of tiles in the explorer (should be set via slider) Action OnTilePick Subscribe to recive a change notification once a tile is picked List<System.Type> Modules List of registered modules GUIContent[] FlagContent List of registered flag buttons Material PreviewMaterial Single instance to (\"Hidden/TilePreview\") Methods Name Usage SaveSettings() Save current settings to file SyncToMap(Tilemap3D map) Limit ranges to current tilemap GetAxis() Get axis order from settings as int3 RegisterModule<iTilemapModule>() Register a module to show in the module menu RegisterFlagContent(GUIContent content, int id) Register a custom flag (0 and 1 are used by autotiling) SettingsFromTile(TilemapData.Tile tile) Copy the tile data to settings and call OnTilePick","title":"TilemapSettings"},{"location":"api/TilemapSettings/#tilemapsettings-editor-only","text":"Settings object that gets stored in ProjectRoot/UserSettings. Save serialization is called when switching away from an active tilemap. Values are mainly modified by package interfaces but can be freely set for extensions as well.","title":"TilemapSettings (Editor only)"},{"location":"api/TilemapSettings/#properties","text":"Type Name Usage int Index Active index of the cursor (zero is empty) int Variant Active sub index of the cursor int Rotation Active rotation of the cursor (0-3) TileFlags Flags Active flags of the cursor bool ShowGrid Shows or hides the grid int GridLayer Active working layer of the grid int GridAxis Display axis of the grid (0=x 1=y 2=z) float3 GridSize Size of a single cell. Should match the provided tile mesh size bool PreviewMode Toggles between shape and textured preview int Randomizer Tile placing setting (0=none 1=variant 2=rotation 3=both) float ExplorerTileSize Display size of tiles in the explorer (should be set via slider) Action OnTilePick Subscribe to recive a change notification once a tile is picked List<System.Type> Modules List of registered modules GUIContent[] FlagContent List of registered flag buttons Material PreviewMaterial Single instance to (\"Hidden/TilePreview\")","title":"Properties"},{"location":"api/TilemapSettings/#methods","text":"Name Usage SaveSettings() Save current settings to file SyncToMap(Tilemap3D map) Limit ranges to current tilemap GetAxis() Get axis order from settings as int3 RegisterModule<iTilemapModule>() Register a module to show in the module menu RegisterFlagContent(GUIContent content, int id) Register a custom flag (0 and 1 are used by autotiling) SettingsFromTile(TilemapData.Tile tile) Copy the tile data to settings and call OnTilePick","title":"Methods"}]}